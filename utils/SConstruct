import os;
import re;

env = Environment();

# All the #includes to local stuff is done with relative junk, so we
# need to include the directory with all the header files. Things
# using the library should use the directory above it! (So the
# directives look like #include <lilyengine/blahblahblah.h> )
env.Append(CPPPATH=[Dir("include/lilyengine")]);

# If we're not on Windows, assume something POSIXy.
if(not(env["PLATFORM"] == "win32")):
    env.Append(LINKFLAGS="-pthread");

env.Append(LINKFLAGS="-g");
env.Append(CXXFLAGS="-g");

commonSources = [
    "src/thread/thread.cpp",
    "src/assetloader/assetloader.cpp",
    "src/math/matrix.cpp",
    "src/math/angle.cpp",
    "src/assert/malassert.cpp",
    "src/sockets/sockets.cpp",
    "src/string/string.cpp",
    "src/string/pooledstring.cpp",
    "src/image/imagedxt.cpp",
    "src/image/image.cpp",
    "src/preprocess/preprocess.cpp",
    "src/console/console.cpp",
    "src/parser/parserxml.cpp",
    "src/parser/parser.cpp",
    "src/derpscript/derpvm.cpp",
    "src/derpscript/derpparser.cpp",
    "src/derpscript/derpparser_value.cpp",
    "src/derpscript/derpparser_function.cpp",
    "src/derpscript/derpcontext.cpp",
    "src/derpscript/derpvm_builtinfunctions.cpp",
    "src/derpscript/derplexer.cpp",
    "src/derpscript/derpexecnode.cpp",
    "src/derpscript/derpparser_block.cpp",
    "src/derpscript/derpparser_ifelse.cpp",
    "src/derpscript/derpobject.cpp",
    "src/derpscript/derpparser_variabledec.cpp",
    "src/derpscript/derpexecnode_function.cpp",
    "src/derpscript/derpexecnode_unarymath.cpp",
    "src/derpscript/derpexecnode_loop.cpp",
    "src/derpscript/derpparser_expression.cpp",
    "src/derpscript/derpparser_debug.cpp",
    "src/derpscript/derpexecnode_binarymath.cpp",
    "src/derpscript/derpparser_statement.cpp",
    "src/derpscript/derperror.cpp",
    "src/derpscript/derpparser_loops.cpp",
    "src/derpscript/derpparser_functioncall.cpp",
    "src/derpscript/derpparser_index.cpp",
    "src/refsystem/refsystem.cpp",
    "src/compress/compress.cpp",
    "src/filesystem/filesystem.cpp",
    "src/filesystem/archive.cpp"];

testSources = [
    "src/thread/_test_thread.cpp",
    "src/sockets/_test_sockets.cpp",
    "src/parser/_test_parser.cpp",
    "src/derpscript/_test_derpscript.cpp",
    "src/compress/_test_compress.cpp",
    "src/filesystem/_test_filesystem.cpp"];

lilyLib = env.Library("lilyengineutils", commonSources);

for s in testSources:
    thisSources = [s]; # + [lilyLib];
    thisProgram = os.path.basename(s);
    thisProgram = re.sub(".cpp$", "", thisProgram);
    testProg = env.Program(
        thisProgram,
        thisSources,
        LIBS=[lilyLib]);

    # TODO: Run the tests (if we're on the same platform as the host).
    # print("Program: " + testProg[0].path);


# Return from this information about how to link it and compile with
# it. Particularly, something that can be fed straight into
# env.Append(). (Use the ** operator to expand it into named values.)
appendValues = {
    "LIBS":lilyLib,
    "CPPPATH":env.Dir("./include")
};
Return("appendValues");

# TODO: Maybe find a way to return that -pthread parameter.



